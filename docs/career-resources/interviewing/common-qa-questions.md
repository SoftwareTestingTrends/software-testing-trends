---
sidebar_position: 3
---

# Common QA Interview Questions

# What is SDLC, and why is it important?

SDLC stands for Software Development Life Cycle. It is a structured process that outlines the steps involved in developing software from conception to deployment and maintenance. The primary goal of SDLC is to produce high-quality software that meets customer requirements, is delivered on time, and stays within budget constraints.

SDLC stands for Software Development Life Cycle. It is a structured process that outlines the steps involved in developing software from conception to deployment and maintenance. The primary goal of SDLC is to produce high-quality software that meets customer requirements, is delivered on time, and stays within budget constraints. 

The importance of SDLC can be understood through several key points:

1. **Structured Approach:** SDLC provides a systematic and organized framework for software development, ensuring that all necessary steps are followed in a logical sequence. This structured approach helps in reducing errors, improving efficiency, and maintaining consistency across projects.

2. **Clear Communication:** SDLC facilitates clear communication among stakeholders, including developers, testers, project managers, and clients. It defines roles and responsibilities, sets expectations, and ensures that everyone is on the same page throughout the development process.

3. **Risk Management:** By breaking the development process into phases like requirements gathering, design, development, testing, deployment, and maintenance, SDLC helps in identifying and mitigating risks early in the project lifecycle. This proactive risk management approach minimizes the chances of project failure or costly rework later on.

4. **Quality Assurance:** SDLC emphasizes quality at every stage of software development. It includes processes for requirements validation, design reviews, code reviews, testing (including unit testing, integration testing, system testing, and acceptance testing), and continuous improvement. This focus on quality assurance leads to the delivery of reliable and bug-free software.

5. **Cost and Time Efficiency:** Following a structured SDLC model can lead to cost and time savings in the long run. By identifying and addressing issues early, avoiding unnecessary rework, and streamlining development processes, SDLC helps in delivering projects within budget and on schedule.

6. **Customer Satisfaction:** Ultimately, SDLC aims to meet customer requirements and deliver software solutions that meet or exceed user expectations. By involving customers in the requirements gathering and testing phases, SDLC ensures that the final product aligns with customer needs and enhances satisfaction.

# What are the different phases/stages of SDLC?
The different phases/stages of SDLC are:

1. **Requirements Gathering:** Gathering and documenting user requirements for the software.

2. **Analysis:** Analyzing the requirements to understand their feasibility and impact on the project.

3. **Design:** Creating a detailed design of the software architecture and system components.

4. **Implementation:** Developing the software based on the design specifications.

5. **Testing:** Conducting various types of testing (unit testing, integration testing, system testing, acceptance testing) to ensure the software meets quality standards.

6. **Deployment:** Deploying the software in the production environment for end-users.

7. **Maintenance:** Providing ongoing support, updates, and enhancements to the software as needed.

# What is the difference between Waterfall and Agile SDLC methodologies?
The main differences between Waterfall and Agile SDLC methodologies are:

1. **Waterfall:**
   - Sequential approach: Each phase (requirements, design, implementation, testing, deployment) is completed before moving to the next.
   - Rigidity: Changes are difficult to accommodate once a phase is completed.
   - Detailed planning upfront: Extensive documentation and planning are done at the beginning of the project.
   - Suitable for well-defined, stable requirements.

2. **Agile:**
   - Iterative and incremental: Work is divided into small iterations or sprints, with frequent feedback and continuous improvement.
   - Flexibility: Emphasizes adaptability to changing requirements throughout the project.
   - Minimal upfront planning: Focuses on delivering working software quickly and adjusting based on feedback.
   - Suitable for projects with evolving or unclear requirements.

Overall, Waterfall is more suitable for projects with well-defined and stable requirements, while Agile is better suited for projects with changing or evolving requirements that require flexibility and frequent collaboration with stakeholders.

# Explain the role of testing in SDLC.
The role of testing in SDLC is crucial for ensuring the quality and reliability of the software being developed. Here are the key aspects of testing in SDLC:

1. **Quality Assurance:** Testing is essential for assuring the quality of the software at each stage of development. It helps identify defects, errors, and inconsistencies early in the process, preventing them from escalating into more significant issues later on.

2. **Validation and Verification:** Testing validates that the software meets the specified requirements and verifies that it functions correctly according to the design specifications.

3. **Risk Mitigation:** Testing helps in mitigating risks by identifying potential issues and vulnerabilities in the software. Addressing these issues early reduces the likelihood of critical failures in the production environment.

4. **Types of Testing:** SDLC includes various types of testing such as unit testing (testing individual components/modules), integration testing (testing the interaction between components/modules), system testing (testing the entire system), and acceptance testing (testing against user requirements).

5. **Continuous Improvement:** Testing contributes to continuous improvement by providing feedback on the software's performance, functionality, and user experience. This feedback loop helps in refining the software and enhancing its overall quality.

6. **Regression Testing:** As changes are made to the software during development, regression testing ensures that existing functionalities are not affected by new updates or modifications.

Overall, testing plays a critical role in SDLC by ensuring that the software meets quality standards, functions as intended, and delivers value to users and stakeholders.

# Explain the concept of version control in SDLC.
Version control in SDLC refers to the management of changes made to software code and assets throughout the development process. It involves tracking, organizing, and coordinating different versions of files to ensure a systematic approach to collaboration and development. Here are key aspects of version control in SDLC:

1. **History Tracking:** Version control systems (VCS) track the history of changes made to files, including who made the changes, when they were made, and what changes were made. This historical data is valuable for understanding the evolution of the software and for troubleshooting issues.

2. **Collaboration:** Version control enables multiple developers to work on the same codebase simultaneously without conflicts. It allows developers to merge their changes seamlessly, ensuring that everyone is working with the latest version of the code.

3. **Branching and Merging:** Version control systems support branching, which allows developers to work on isolated features or bug fixes without affecting the main codebase. Branches can later be merged back into the main codebase, maintaining a clean and organized development workflow.

4. **Revert Changes:** Version control systems allow developers to revert to previous versions of files if needed. This feature is crucial for undoing changes that introduce errors or unexpected behavior.

5. **Code Reviews:** Version control systems facilitate code reviews by providing tools for reviewing changes, adding comments, and discussing code improvements. Code reviews help maintain code quality and ensure that changes meet project standards.

6. **Backup and Disaster Recovery:** Version control serves as a backup mechanism for code and project assets. In case of data loss or system failure, developers can restore previous versions from the version control system, ensuring continuity of development.

Popular version control systems include Git, SVN (Subversion), Mercurial, and Perforce. These systems are integral to modern software development practices, promoting collaboration, code quality, and efficient project management throughout the SDLC.

# How do you handle changes or updates during different phases of SDLC?
Handling changes or updates during different phases of SDLC involves a systematic approach to manage and incorporate modifications effectively. Here are some steps to handle changes throughout the SDLC phases:

1. **Requirements Gathering Phase:**
   - Encourage open communication with stakeholders to capture detailed and accurate requirements.
   - Document requirements using a structured format to facilitate easy updates and revisions.
   - Conduct regular reviews and validations to ensure requirements alignment with project goals.

2. **Analysis and Design Phase:**
   - Evaluate the impact of proposed changes on the design and architecture.
   - Update design documents, diagrams, and specifications to reflect the changes.
   - Collaborate with stakeholders and development team to finalize design changes.

3. **Implementation Phase:**
   - Prioritize changes based on their impact and urgency.
   - Implement changes following coding standards and best practices.
   - Conduct thorough testing of modified functionalities to validate the changes.

4. **Testing Phase:**
   - Include change-specific test cases to verify the updated functionalities.
   - Perform regression testing to ensure that existing functionalities are not affected by changes.
   - Collaborate with the development team to address any issues or bugs identified during testing.

5. **Deployment and Maintenance Phase:**
   - Plan and execute deployment of updated software components.
   - Monitor post-deployment performance and user feedback for any additional changes or improvements.
   - Maintain documentation and version control to track changes and updates accurately.

Key principles for handling changes effectively include maintaining clear communication among project stakeholders, documenting changes comprehensively, prioritizing changes based on impact and urgency, and leveraging version control systems for tracking and managing updates throughout the SDLC. Additionally, agile methodologies emphasize adaptability to changes, continuous feedback, and iterative development, which can aid in handling changes more efficiently during the software development process.

# What is Continuous Integration (CI) and Continuous Deployment (CD) in SDLC?
CI/CD practices automate the integration, testing, and deployment of code, leading to faster and more reliable software delivery.

Continuous Integration (CI) and Continuous Deployment (CD) are practices in software development that aim to automate and streamline the process of delivering high-quality software. Here's an explanation of CI and CD in the context of SDLC:

1. **Continuous Integration (CI):**
   - CI is a development practice where developers regularly integrate their code changes into a shared repository multiple times a day.
   - Each integration triggers an automated build and a series of automated tests to validate the code changes.
   - The goal of CI is to detect integration issues early, ensure code quality, and promote collaboration among developers.
   - CI tools like Jenkins, Travis CI, and GitLab CI automate the build and test processes, providing feedback to developers quickly.

2. **Continuous Deployment (CD):**
   - CD is an extension of CI that automates the deployment of validated code changes to production environments.
   - After code passes the automated tests in the CI pipeline, it can be automatically deployed to staging or production environments.
   - CD pipelines may include additional automated tests, such as integration testing and user acceptance testing, before deployment to ensure software quality.
   - The goal of CD is to deliver software changes to users rapidly, reliably, and with minimal manual intervention.
   - CD tools like Docker, Kubernetes, Ansible, and AWS CodePipeline automate deployment processes and manage infrastructure configurations.

In summary, CI focuses on integrating code changes frequently and running automated tests to maintain code quality, while CD extends this by automating the deployment of validated code changes to production environments. Together, CI/CD practices improve development efficiency, reduce deployment risks, and enable faster delivery of software updates to end-users.

# What is a defect or bug?
Nonconformance to requirements or functional/program specification.

1. Bug causes system crash or data loss.

2. Bug causes major functionality or other severe problems; product crashes in obscure cases.

3. Bug causes minor functionality problems, may affect "fit and finish".

4. Bug contains typos, unclear wording or error messages in low visibility fields.

# What is the difference between priority & severity?

Priority and severity are two distinct concepts often utilized to prioritize the resolution of issues. Here's the difference between them:

1. **Severity:**
   - Severity refers to the impact or seriousness of a bug or defect on the functionality of the software.
   - It indicates how severe the consequences of the bug are on the system's usability, functionality, or performance.
   - Severity is typically categorized into several levels, such as:
     - Critical: The bug causes system failure or a complete loss of functionality, making the software unusable. We have to fix this before we release. We will lose substantial customers or money if we don’t.
     - Major/High: The bug significantly impacts the functionality or performance of the software but does not cause a complete system failure. We’d like to fix this before we release. It might perturb some customers, but we don’t think they’ll throw out the product or move to our competitors. If we don’t fix it before we release, we either have to do something to that module or fix it in the next release.
     - Moderate/Medium: The bug has a noticeable impact on usability or functionality but does not severely affect the overall performance.
     - Minor/Low: The bug has minimal impact on usability or functionality and does not significantly affect the overall performance of the software. We’d like to fix this before we throw out this product.

2. **Priority:**
   - Priority, on the other hand, refers to the order in which bugs or issues should be addressed or resolved based on their importance or urgency.
   - It indicates how quickly the bug needs to be fixed relative to other bugs, taking into account factors such as user impact, project timelines, and business requirements.
   - Priority is typically categorized into several levels, such as:
     - P0 - Urgent/Immediate: Must fix as soon as possible. Bug is blocking further progress in this area. The bug requires immediate attention and should be fixed as soon as possible, as it severely impacts the system's usability or functionality.
     - P1 - High: Should fix soon. Fix before next build to test. The bug should be addressed with high priority, but it may not require immediate attention. It has a significant impact on usability or functionality.
     - P2 - Normal/Medium: Fix before final release. The bug should be addressed in the normal course of development and testing. It has a noticeable impact on usability or functionality but does not require immediate attention.
     - P3 - Low: We probably won’t get to these, but we want to track them anyway. The bug has minimal impact on usability or functionality and can be addressed at a later stage. It is not considered a high priority for resolution.
    
* Priority is Relative; Severity is Absolute. Priority is a subjective evaluation of how important an issue is, given other tasks in the queue and the current schedule. The priority reflects importance to the business.
* Severity refers to the impact or seriousness of a bug, while priority refers to the order in which bugs should be addressed or resolved based on their importance or urgency. Both severity and priority are important considerations in bug tracking and software testing to ensure that critical issues are addressed promptly, and the overall quality of the software is maintained.

# What is the difference between validation and verification? Please explain with examples.

Validation and verification are two terms often used in the context of software testing, but they refer to different processes.

1. **Verification:**
   - Verification is the process of ensuring that the software product satisfies or meets the specified requirements and specifications.
   - It involves checking whether the software has been built correctly according to the design specifications and requirements.
   - Verification answers the question: "Are we building the product right?"

**Example of Verification:**
   - Suppose you are building a calculator application. Verification in this context would involve checking whether the calculator functions as intended according to the design specifications. For instance:
     - Verifying that pressing the "+" button performs addition correctly.
     - Verifying that pressing the "-" button performs subtraction correctly.
     - Verifying that the displayed result matches the expected result for various mathematical operations.

2. **Validation:**
   - Validation, on the other hand, is the process of ensuring that the software meets the needs and expectations of the end-users or stakeholders.
   - It involves evaluating the software to determine whether it solves the right problem and meets the user's requirements and expectations.
   - Validation answers the question: "Are we building the right product?"

**Example of Validation:**
   - Continuing with the example of the calculator application, validation would involve testing the software with real users or stakeholders to ensure that it meets their needs and expectations. For instance:
     - Validating that the calculator's user interface is intuitive and easy to use.
     - Validating that the calculator's functionalities meet the needs of users, such as students, professionals, or everyday users.
     - Obtaining feedback from users about their experience using the calculator and making any necessary improvements based on their feedback.

In summary, verification focuses on ensuring that the software is built correctly according to specifications, while validation focuses on ensuring that the software meets the needs and expectations of the users. Both processes are essential components of software testing and are conducted throughout the software development lifecycle to ensure the delivery of high-quality software products.

**Validation**: The process of evaluating software at the end of the software development process to ensure compliance with software requirements.

**Verification**: Verification is a quality process that is used to evaluate whether or not a product, service, or system complies with a regulation, specification, or conditions imposed at the start of a development phase.

It is sometimes said that validation ensures that ‘you built the right thing’ and verification ensures that ‘you built it right’.

# What is a Test Bed?

A test bed is a dedicated environment or setup used for testing software, hardware, or systems in a controlled and reproducible manner. It provides a standardized platform where tests can be conducted, and results can be observed, analyzed, and compared. Test beds are commonly used in various fields such as software development, quality assurance, research, and experimentation. 

# What are the different techniques for test case design? Can you explain a few of them?

1. **Equivalence Partitioning:**
   - **Explanation:** Equivalence Partitioning is a technique that divides the input domain of a software system into classes or partitions of equivalent data. Test cases are then designed to cover each partition at least once, as the behavior of the software should be the same for any input within the same partition.
   - **Example/Scenario:** Consider a login page where users enter their username and password. Equivalence Partitioning would involve dividing the input domain of usernames into partitions such as valid usernames, invalid usernames (e.g., non-existent usernames, usernames with incorrect format), and special cases (e.g., usernames with maximum length). Test cases would be designed to cover each partition, ensuring that the login functionality behaves correctly under various input conditions.

2. **Boundary Value Analysis:**
   - **Explanation:** Boundary Value Analysis focuses on testing the boundaries of input domains, as errors often occur at the extremes of data ranges. Test cases are designed to include boundary values, as well as values immediately above and below these boundaries, to ensure robustness and identify potential off-by-one errors.
   - **Example/Scenario:** Consider a software application that accepts numeric input for a field with a defined range (e.g., 1 to 100). Boundary Value Analysis would involve testing input values at the lower boundary (1), upper boundary (100), and just beyond the boundaries (0 and 101). This helps identify any issues related to boundary conditions, such as incorrect validation or unexpected behavior.

3. **Decision Table Testing:**
   - **Explanation:** Decision Table Testing is a technique used to test systems that involve complex business rules or logical conditions. It involves creating a table that lists all possible combinations of inputs and their corresponding outputs or actions. Test cases are then derived from the decision table to cover different combinations effectively.
   - **Example/Scenario:** Consider a banking system that determines whether a customer is eligible for a loan based on criteria such as income, credit score, and employment status. Decision Table Testing would involve creating a table listing all possible combinations of these criteria and the corresponding decisions (approve or reject). Test cases would be derived from this table to ensure comprehensive coverage of decision logic.

4. **State Transition Testing:**
   - **Explanation:** State Transition Testing is used to test systems that exhibit different states or modes of operation, where transitions between states occur in response to specific events or conditions. Test cases are designed to validate transitions between states and the correct behavior of the system in each state.
   - **Example/Scenario:** Consider a vending machine that operates in different states such as idle, accepting coins, dispensing products, and out of order. State Transition Testing would involve designing test cases to validate transitions between these states (e.g., from idle to accepting coins when a coin is inserted) and the correct behavior of the vending machine in each state (e.g., dispensing the correct product when selected).

5. **Use Case Testing:** Based on use cases or user scenarios, this technique tests the system's functionality from the perspective of end users. Test cases are derived from use case descriptions to validate system behavior in real-world scenarios.

6. **Pairwise Testing:** Also known as all-pairs testing, this technique focuses on testing combinations of input parameters by selecting a subset of combinations that cover all possible pairs of parameters. It aims to achieve thorough coverage while minimizing the number of test cases.

7. **Orthogonal Array Testing:** Similar to pairwise testing, this technique uses orthogonal arrays to systematically generate test cases covering combinations of input parameters. It helps reduce the number of test cases required for comprehensive coverage.

8. **Error Guessing:** Relies on the tester's intuition, experience, and domain knowledge to identify potential errors and design test cases targeting those areas. Test cases are based on educated guesses about where defects are likely to occur.   

These techniques are valuable tools in the test case designer's arsenal, helping to ensure thorough testing coverage and identify potential defects in software systems across various domains and complexities.

# What are common testing types?

## **Integration Testing:**

Testing of combined parts of an application to determine if they function together correctly. Usually performed after unit and functional testing. This type of testing is especially relevant to client/server and distributed systems.

## **Performance Testing:**

Testing conducted to evaluate the compliance of a system or component with specified performance requirements. Often this is performed using an automated test tool to simulate large number of users. Also know as "Load Testing".

## **Black Box Testing:**

Testing based on an analysis of the specification of a piece of software without reference to its internal workings. The goal is to test how well the component conforms to the published requirements for the component.

## **Regression Testing:**

Retesting a previously tested program following modification to ensure that faults have not been introduced or uncovered as a result of the changes made.

## **Sanity Testing:**

Brief test of major functional elements of a piece of software to determine if it’s basically operational.

## **Smoke Testing:**

A smoke test is a group of test cases that establish that the system is stable and all major functionality is present and works under “normal” conditions  Smoke tests are often automated, and the selection of the test cases are broad in scope. The smoke tests might be run before deciding to proceed with further testing (why dedicate resources to testing if the system is very unstable). The purpose of smoke tests is to demonstrate stability, not to find bugs with the system.

A subset of the regression test cases can be set aside as smoke tests.

## End-to-End testing:

Testing a complete application environment in a situation that mimics real-world use, such as interacting with a database, using network communications, or interacting with other hardware, applications, or systems if appropriate.

## **Gray Box Testing:**

A combination of Black Box and White Box testing methodologies: testing a piece of software against its specification but using some knowledge of its internal workings.

## **White Box Testing:**

Testing based on an analysis of internal workings and structure of a piece of software. Includes techniques such as Branch Testing and Path Testing. Also knows as Structural Testing and Glass Box Testing.

## **Monkey Testing:**

Monkey (light weight jumps easily) testing resembles the behavior of a monkey on a tree....it jumps from one branch to another with out any sequence/order...

Testing a system or an Application on the fly, i.e. just few tests here and there to ensure the system or an application does not crash out. It is also called Random testing

## **Gorilla Testing:**

Gorilla (heavy weight can't move so easily) Testing on the other hand is testing a function or module heavily....for example testing a email functionality by click on "send email" button...or creating an order by click on "check out" button... continuously for more times...(with out stopping after the first click..) in the first case it will send many emails if it is delivering for each click event...same away it may try to create multiple orders if it is processing order for each click event...and some times may go in to loop and application will hang after consuming more resources.

## **Negative Testing:**

Testing aimed at showing software does not work. Also known as "test to fail".

## **Responsiveness/Stability Testing**

### **Important Facts**

- Find the system bottlenecks to optimize them
- Monitor system performance and endurance under different workloads
    - The system should perform as expected under heavy loads

### **Examples**

- Flooding an e-commerce website with online orders until it crashes (Stress Testing)
    - Pushing the system beyond its limits
- Having many users visit and browse your website frequently (Endurance Testing)
    - Continuous workload
- Handling a massive influx of online shoppers during a sneaker drop (Spike Testing)
    - The workload is abruptly increased

# **What is the difference between software testing and software verification?**

- Software Testing is validating whether software meets the consumer's needs through the design of test cases
    - This cheat sheet focuses on Software Testing and its applications
- Software Verification is more rigorous; formally proving using a proof system whether software is "correct" to its specification
    - Not all software can be formally verified
      
# **What is the difference between Load & Stress Testing**

- Load testing is performed to find out the upper limit of the system or application.
- Stress testing is performed to find the behavior of the system under pressure.
- The factor tested during load testing is performance. The factor tested during stress testing is robustness and stability.

# What are the key elements of good test cases?

**Simplicity**

- Be clear and concise. Write not for yourself, but for the person after you.

**Maximum coverage**

- We want to minimize our test cases while maximizing the chance to find a defect

**Repeatability**

- The test case should always generate the same results, no matter the environment
  
## What if there isn’t enough time for thorough testing? OR How do you prioritize test cases?

**Sample Answer:** To prioritize test cases, I employ a systematic approach that takes into account several key factors:

The best approach to prioritize test cases involves considering various factors to ensure efficient and effective testing. Here's a comprehensive answer:

"To prioritize test cases, I employ a systematic approach that takes into account several key factors:

1. **Risk-Based Prioritization:** I prioritize test cases based on the perceived risk associated with the functionality or feature being tested. High-risk areas, where failure could have significant consequences or impact user experience, are tested with higher priority.
* Find out Important functionality is your project
* Find out High-risk module of the project
* Which functionality has the largest safety impact?
* What do the developers think are the highest-risk aspects of the application?
* Which parts of the application were developed in rush or panic mode?

2. **Business Impact:** Understanding the criticality of features to the business objectives and end-users is essential. Test cases related to core functionalities or critical user workflows are prioritized to ensure that the most important aspects of the software are thoroughly tested.
*  Which aspects of the application are most important to the customer?
*  Which functionality has the largest financial impact on users?
*  What kinds of problems would cause the worst publicity?
*  What kinds of problems would cause the most customer service complaints?
  
3. **Requirements Coverage:** Ensuring adequate coverage of functional and non-functional requirements is crucial. I prioritize test cases that address essential requirements and user scenarios, ensuring that the software meets specified criteria and user expectations.

4. **Frequency of Use:** Test cases covering functionalities that are frequently used by end-users are given higher priority. Prioritizing these test cases helps identify and address issues that may affect a significant portion of the user base, thereby enhancing user satisfaction and retention.
* Which functionality is most visible to the user?

5. **Dependency and Interoperability:** Test cases for features that have dependencies on other modules or external systems are prioritized to ensure compatibility and seamless integration. Testing these interactions early can prevent cascading failures and streamline the overall testing process.
* Which parts of the code are most complex, and thus most subject to errors?
  
6. **Time and Resource Constraints:** Considering project timelines and resource availability, I prioritize test cases that can provide maximum coverage within the available time and resources. This may involve focusing on critical paths, high-impact functionalities, or areas prone to defects.
* What kinds of tests could easily cover multiple functionalities?

7. **Regression Impact:** Test cases that cover critical functionalities and areas prone to regression issues are given priority during regression testing cycles. This ensures that changes or updates to the software do not inadvertently introduce new defects or regressions in existing functionality.

By considering these factors in conjunction with each other, I ensure that test cases are prioritized effectively to maximize testing efficiency, mitigate risks, and deliver high-quality software that meets business and user requirements."

# Can you walk us through your process of creating a test case?

**Sample answer:**

The process of creating a test case involves several steps, each aimed at ensuring thorough testing coverage and effective validation of software functionality. Here's a comprehensive answer:

"Absolutely. My process of creating a test case typically follows these steps:

1. **Understanding Requirements:** The first step is to thoroughly understand the requirements or specifications of the feature or functionality being tested. This involves reviewing documentation, user stories, and any other relevant materials to gain a clear understanding of what the software is supposed to do.

2. **Identifying Test Scenarios:** Based on the requirements, I identify various test scenarios that cover different aspects of the functionality. These scenarios represent specific situations, inputs, or actions that users may encounter while using the software.

3. **Designing Test Cases:** For each test scenario, I design detailed test cases that outline the steps to be followed, the inputs to be provided, the expected outcomes, and any additional conditions or criteria for validation. Test cases are designed to be clear, concise, and executable, ensuring that they effectively verify the intended behavior of the software.

4. **Incorporating Test Data:** Test cases often require specific test data to simulate real-world conditions or edge cases. I ensure that appropriate test data is identified and incorporated into the test cases, covering a range of scenarios and conditions to validate the software under various circumstances.

5. **Reviewing and Refining:** Before finalizing the test cases, I conduct a thorough review to ensure accuracy, completeness, and relevance. This may involve collaborating with stakeholders, developers, or other testers to gather feedback and refine the test cases as needed.

6. **Organizing Test Suites:** Once the test cases are finalized, I organize them into logical groupings or test suites based on factors such as functional areas, priorities, or testing phases. This helps streamline test execution and management, making it easier to track progress and identify coverage gaps.

7. **Documenting Test Cases:** Proper documentation of test cases is essential for clarity, repeatability, and traceability. I document each test case with detailed descriptions, steps, expected results, and any relevant attachments or references, ensuring that the testing process is well-documented and transparent.

8. **Executing Test Cases:** Finally, I execute the test cases according to the planned test strategy, recording actual results and any deviations from expected behavior. I pay close attention to detail, documenting any defects or issues encountered during testing and providing clear feedback to the development team for resolution.

By following this process, I ensure that test cases are meticulously designed, thoroughly validated, and effectively executed to deliver high-quality software that meets user requirements and expectations."

# How do you ensure thorough test coverage?

**Sample answer:** To ensure thorough test coverage, I employ a combination of systematic approaches and techniques tailored to the specific context of the software under test. Here's how I ensure comprehensive coverage:

1. **Requirements-Based Testing:** I start by thoroughly understanding the requirements and specifications of the software. By mapping test cases directly to requirements, I ensure that all functional and non-functional aspects are adequately covered, leaving no ambiguity in testing objectives.

2. **Equivalence Partitioning and Boundary Value Analysis:** These techniques help me identify and prioritize test cases by partitioning input domains and focusing on boundary conditions. By selecting representative values from each partition and testing boundary conditions, I ensure that critical areas are thoroughly exercised.

3. **Risk-Based Testing:** Prioritizing test cases based on perceived risks helps me allocate testing resources efficiently. High-risk areas, where failures could have significant consequences, are tested more extensively to mitigate potential impacts on the software's quality and reliability.

4. **Exploratory Testing:** This technique allows me to explore the software dynamically, uncovering unforeseen issues and verifying the behavior under various scenarios. Combining structured test cases with exploratory testing ensures a balanced approach to uncovering defects and validating the software's robustness.

5. **Code Coverage Analysis:** While not a substitute for functional testing, code coverage analysis helps me assess the effectiveness of test cases in exercising different parts of the codebase. By aiming for high code coverage, I ensure that critical code paths and branches are adequately tested, reducing the likelihood of undiscovered defects.

6. **Regression Testing Suites:** Maintaining regression testing suites helps ensure that previously validated functionality remains intact after each software change. By including both core functionalities and critical edge cases in regression test suites, I verify that new changes do not inadvertently introduce regressions or break existing features.

7. **User Scenario Testing:** Understanding typical user workflows and scenarios helps me design test cases that closely mimic real-world usage. By testing end-to-end user scenarios, including error-handling and recovery paths, I ensure that the software behaves as expected in various usage contexts.

8. **Cross-Browser and Cross-Platform Testing:** Given the diversity of devices and platforms used by end-users, I perform testing across multiple browsers, operating systems, and devices to ensure compatibility and consistency. This helps uncover issues specific to different environments, ensuring a seamless user experience across all platforms.

By integrating these strategies into my testing approach, I ensure that test coverage is comprehensive, effective, and aligned with the software's quality goals and user expectations."

# Practical Testing

## **What kind of testing would you perform on a retractable ballpoint pen during the design process to verify its quality?**

Try to be specific and creative! Think about how all the individual components interact with each other.

### **Unit Testing**

- Does the ink tube leak?
- Is the pen's body durable?
- Does the ink tube retract properly?

### **Smoke Testing**

- Can the pen write?

### **Integration Testing**

- Do all the pen parts fit inside the body?
- Does the retraction mechanism interfere with the writing mechanism?

### **Regression Testing**

- A new click-spring mechanism is introduced to the pen, does this affect pen retraction?
- After assembling the pen, does the pen leak?

### **Acceptance Testing**

- Is the pen comfortable?
- Does the pen write smoothly?

### **Usability Testing**

- Can users easily figure out how to retract the pen?
- Will users recognize that it is, in fact a pen?

## What factors will you consider when designing test cases for an online educational platform?

**Sample Answer:** Designing test cases for an online educational platform requires careful consideration of various factors to ensure that the platform meets the needs of both learners and educators while maintaining a high level of quality and reliability. Some key factors I will consider include:

1. **User Experience (UX):** Ensuring a seamless and intuitive user experience is paramount for an online educational platform. I design test cases to validate the usability of the platform's interface, navigation flows, and accessibility features across different devices and screen sizes. This includes testing for ease of course enrollment, content discovery, progress tracking, and interaction with learning materials.

2. **Functionality and Feature Coverage:** Coursera offers a wide range of features and functionalities, including course enrollment, video lectures, quizzes, assignments, peer reviews, and discussion forums. I design test cases to cover each of these features comprehensively, ensuring that they function as intended and meet the requirements specified by both learners and course instructors.

3. **Content Delivery and Accessibility:** Coursera hosts a vast repository of educational content, including videos, slides, documents, and interactive exercises. Test cases are designed to validate the delivery and accessibility of various types of content, ensuring that learners can access and interact with course materials effectively, regardless of their location or device.

4. **Scalability and Performance:** As Coursera caters to a large and diverse user base, it's essential to test the platform's scalability and performance under different load conditions. I design test cases to simulate concurrent user interactions, course enrollments, and content accesses to assess the platform's responsiveness and stability under peak usage scenarios.

5. **Security and Data Privacy:** Protecting user data and ensuring the security of the platform are critical considerations for any online educational platform. I design test cases to validate the implementation of security measures such as authentication, authorization, data encryption, and secure communication protocols to safeguard user information and prevent unauthorized access or data breaches.

6. **Compatibility and Interoperability:** Coursera should be compatible with a wide range of web browsers, operating systems, and devices to accommodate diverse user preferences and environments. I design test cases to verify cross-browser and cross-platform compatibility, ensuring consistent performance and functionality across different configurations.

7. **Regulatory Compliance:** Compliance with relevant regulations and standards, such as GDPR for data protection and accessibility standards for users with disabilities, is essential for maintaining legal and ethical integrity. I design test cases to verify compliance with these requirements, ensuring that Coursera adheres to industry best practices and legal obligations.

By considering these factors and incorporating them into the test case design process, I ensure that Coursera delivers a robust, user-friendly, and high-quality online learning experience for learners worldwide."

## **How many testers does it take to change a light bulb?**

- None. Testers do not fix problems - they just find them.

# **What are microservices?**

Microservices are segments of an application. Each microservice performs one service, and multiple integrated microservices combine to make up the application. Although the name seems to imply that microservices are tiny, they do not have to be.

One of the advantages of building an application as a collection of microservices is that developers can update one microservice at a time instead of updating the entire application when they need to make changes. Building an application as a collection of functions, as in a serverless architecture, offers the same benefit but at a more granular level.

## **Monolith**

- Monolith - Everything is togather; Individual components are hard to upgrade or scale
- Codebase lives on the same server & usually in same repository.

## **Non-Monolith (MicroService)**

- Isolated components that are divided by responsibility
- Independent scaling of the components
- Standardized interface (API) so any service can use it
- Can be independently developed by different teams

# **Caching**

Caching is a technique used in computing to store and retrieve data more quickly by keeping a copy of frequently accessed or recently used information in a location that is faster to access than the original source. The primary purpose of caching is to improve the performance and efficiency of a system by reducing the time it takes to fetch data.

### **Types of caching:**

### **Client Side**

- Browser cache
- Service worker/ Single Page Apps (SPAs)

### **Network**

- DNS cache
- Content Delivery Network
- HTTP cache (Varnish)

### **Server Cache**

- Object cache
- Database cache

# Additional Resources:
- [AlgoDaily: Interview Cheat Sheets by Topic](https://algodaily.com/lessons/qa-testing-interview-questions-cheat-sheet)
- https://applitools.com/blog/answers-for-test-engineers/
- https://bughuntersam.com/interviewing-technical-testers/
- https://sites.google.com/site/techsessions/Home/testing/testing-definitions
- https://algodaily.com/lessons/qa-testing-interview-questions-cheat-sheet
- [Slides: Ace Your Technical Job Interview](https://slides.com/angiejones/technical-interviews)
- [Slides by Angie Jones](https://slides.com/angiejones/)
- [Sell Yourself: How to Ace the “Why Hire You?” Question](https://testertips.com/why-should-we-hire-you-as-a-software-tester-2/)
- [LinkedIn: Manual Test Interview Questions](https://www.linkedin.com/feed/update/urn:li:activity:7122647419766407168?utm_source=share&utm_medium=member_desktop)

